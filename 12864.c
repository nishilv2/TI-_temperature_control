#include "12864.h"
#include<MSP430g2553.h>
#define lcd_delay 20
static void write_byte(uchar  date)
{
    uchar  i;
    for(i=0;i<8;i++)
    {
        SCLK_lcd1;   //一个高脉冲
        //NOP();
//		Delay_nus(lcd_delay); // 600us实际700us左右
		delay_us(lcd_delay);
        //date<<=1;  //高位先发送  延时一下
		if(date&0x80)
        {
		  SID_lcd1;//把数据给数据口
        }
		else
		  SID_lcd0;
		date = date<<1;
		//NOP();
//        Delay_nus(lcd_delay); // 600us实际700us左右
        delay_us(lcd_delay);
		SCLK_lcd0;  //下降沿读走数据
        //NOP();
//		Delay_nus(lcd_delay); // 600us实际700us左右
		delay_us(lcd_delay);
    }
}


void write_12864_byte(uchar C_D,uchar  date)
{
    //check_busy();      //读忙
	//Delay_nms(2);
//	NOP();
	delay_us(10);
    CS_lcd1;            //使能液晶
    if(C_D)            //C_D为1时写数据
        write_byte(0xfa); //1111 1010
    else               //C_D为0时写指令
        write_byte(0xf8); //1111 1000
    write_byte(0xf0&date);//写数据的高四位
    write_byte(0xf0&(date<<4));//写数据的低四位
    CS_lcd0;            //关闭使能
    //check_busy();      //写完直接查忙 不容易出错 特别对1T单片机来说
	//Delay_nms(2);
	//NOP();
}

/*液晶LCD12864初始化*/
void SInit_12864(void)
{
    P2DIR|=BIT0+BIT1+BIT2;
//	Delay_nms(2);
    delay_ms(2);
    CS_lcd0;
    SID_lcd0;
    SCLK_lcd0;
//	Delay_nms(2);
    delay_ms(2);

/**********************以下是基本指令(即RE=0时,)的功能说明 ********************/
    write_12864_byte(0,0x30);          //先确定使用8位总线
    write_12864_byte(0,0x01);          // 清零 将DDRAM填满“20H”(空格)代码,并且设定DDRAM的地址计数器(AC)为00H;
                                       //               更新设置进入设定点将I/D设为1，游标右移AC加1。
    write_12864_byte(0,0x02);          //0000 001X      设定 DDRAM 的地址寄存器为00H，并且将游标移到开头原点位置；
                                       //               这个指令并不改变DDRAM的内容。
    write_12864_byte(0,0x06);          //0000 01 I/D S  S为0,I/D为1(0)是游变右(左)移 DDRAM地址计数器(AC)加(减)1
                                       //               S为1,I/D为1(0)时画面整体左(右)移
    write_12864_byte(0,0x0c);          //0000 1DCB  D=1(0)整体显示开(关),但是不改变DDRAM 内容
                                       //           C=1(0)游标开(关), B=1(0)游标位置显示反白开(关)
//    write_12864_byte(0,0x14);//0001 S/C R/L XX        这条指令不改变DDRAM的内容
                             /*         S/C R/L 方向 AC的值
                                        L L 游标向左移动 AC=AC-1
                                        L H 游标向右移动 AC=AC+1
                                        H L 显示向左移动，游标跟着移动 AC=AC
                                        H H 显示向右移动，游标跟着移动 AC=AC */
    write_12864_byte(0,0x30);//001DL X RE XX
                             /* DL=1,8位MPU接口；DL=0,4位MPU接口
                                RE＝1，扩充指令集；RE＝0，基本指令集
                                同一指令的动作不能同时改变DL和RE，需先改变DL再改变RE才能确保设置正确*/
//    write_12864_byte(0,0x30);//01 A5 A4 A3 A2 A1 A0
                             /*设定CGRAM 地址到地址计数器（AC） ，AC范围为00H～3FH需确认扩充指令中SR＝0
                             （卷动位置或RAM地址选择）*/
//********************************************************************************************************

/*******************************************************************************************************
以下是扩充指令(即RE=1时)详细说明
     write_12864_byte(0,0x01);//0000 0001  进入待命模式，执行如何其它指令都可以结束待命模式；
                                           该指令不能改变RAM的内容。
     write_12864_byte(0,0x02);//0000 001 SR 当SR=1时,允许输入垂直卷动地址
                                            当SR=0时,允许输入IRAM地址(扩充指令)及允许设定CGRAM地址(基本指令)
     write_12864_byte(0,0x04);//0000 01 R1 R0  选择R1R0行反白
     write_12864_byte(0,0x04);//0000 1 SL 00  SL＝1(0)，脱离(进入)睡眠模式
     write_12864_byte(0,0x30);//001DL X RE G X  DL=1,8位MPU接口；DL=0,4位MPU接口
                                                RE＝1,扩充指令集;RE＝0,基本指令集
                                                G＝1,绘图显示开;G＝0,绘图显示关
                                                同一指令的动作不能同时改变RE及DL、G，需先改变DL或G再改变RE才能确保设置正确
     write_12864_byte(0,0x40);//01 A5 A4 A3 A2 A1 A0  SR=1,A5～A0为垂直卷动地址；SR=0,A3～A0为IRAM地址
                              //设定绘图RAM地址,设定先设置垂直位置再设置水平位置(连续写入2字节数据来完成垂直与水平坐标的设置)
     write_12864_byte(0,0x80);//1 0 A5 A4 A3 A2 A1 A0      设置垂直位置(以位为单位)
     write_12864_byte(0,0x80);//1 0  0  0  A3 A2 A1 A0     设置水平位置(以字节单位)指针可自增
                                                           分两屏：低八个字节为上半屏 高八个字节为下半屏
**********************************************************************************************************/
}
/*LCD12864 清屏*/
void LCD12864_Clear(void)
{
    write_12864_byte(0,0x01); //清屏指令
 //   Delay_nms(2);                 //延时1.6ms
    delay_ms(2);
}
void LCD12864_str(uchar  hang,uchar  lie,uchar  *s) // 1-4行；1-16列
{
    uchar  add,i;
    switch (hang)
    {
        case 1:
            add=0x80;break;
        case 2:
            add=0x90;break;
        case 3:
            add=0x88;break;
        case 4:
            add=0x98;break;
        default:
            return;break;
    }
    if(lie>16)
        return;
    write_12864_byte(0,add+((lie+1)/2)-1);//液晶一行中只有八个地址 可是显示字符可以有16个
    if((lie%2)==0)                    //判断是否为偶数列 若是则要先写一个“20H”
         write_12864_byte(1,' ');
    for(i=1;;i++)
    {
        write_12864_byte(1,*s++);
        if((lie+i>16)||(*s=='\0'))   //判断这行是否写满或者字符串结束
            break;
    }
}

void LCD12864_str_ram(uchar  hang,uchar  lie,   uchar  *s) // 1-4行；1-16列
{
    uchar  add,i;
    switch (hang)
    {
        case 1:
            add=0x80;break;
        case 2:
            add=0x90;break;
        case 3:
            add=0x88;break;
        case 4:
            add=0x98;break;
        default:
            return;break;
    }
    if(lie>16)
        return;
    write_12864_byte(0,add+((lie+1)/2)-1);//液晶一行中只有八个地址 可是显示字符可以有16个
    if((lie%2)==0)                    //判断是否为偶数列 若是则要先写一个“20H”
         write_12864_byte(1,' ');
    for(i=1;;i++)
    {
        write_12864_byte(1,*s++);
        if((lie+i>16)||(*s=='\0'))   //判断这行是否写满或者字符串结束
            break;
    }
}

/*在1602第hang行第lie列开始显示*s 汉字*/
void LCD12864_Chinese(uchar  hang,uchar  lie, uchar  *s)// 1-4行；1-8 -- 相当于1-16列
{
    uchar  add,i=0;
    switch (hang)
    {
        case 1:
            add=0x80;break;
        case 2:
            add=0x90;break;
        case 3:
            add=0x88;break;
        case 4:
            add=0x98;break;
        default:
            return;break;
    }
    if(lie>8)
        return;
    write_12864_byte(0,add+lie-1); //选择显示的地址
    for(i=1;;i++)
    {
        write_12864_byte(1,*s++);   //一个汉字有两个字节
        write_12864_byte(1,*s++);
        if((lie+i>8)||(*s=='\0'))   //判断这行是否写满或者字符串结束
            break;
    }
}
/*在12864第hang行第lie列开始显示long 数据 */
void LCD12864_Long(uchar   hang,uchar   lie,long   dws)	// 1-4行；1-16列
{
	long   cs=dws;

	 uchar sz1[11]={0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,'\0'};
	 uchar sz2[12]={'-',0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,'\0'};
	uchar i=0;
	if(cs>=0)
	{
	    for(;;i++)
	    {
	         if(cs/10==0)
		         break;
		     cs=cs/10;
	    }
		for(;i>=0;i--)
		{
			sz1[i]=dws%10+0x30;
			if(dws/10==0)
				break;
			dws=dws/10;
		}
        LCD12864_str_ram(hang,lie,sz1);
	} else
	{
	    cs = -cs;
		dws = -dws;
		for(;;i++)
	    {
	         if(cs/10==0)
		         break;
		     cs=cs/10;
	    }
		for(;i>=0;i--)
		{
			sz2[i+1]=dws%10+0x30;
			if(dws/10==0)
				break;
			dws=dws/10;
		}
//		LCD12864_str(hang,lie,"-");
        LCD12864_str_ram(hang,lie,sz2);
	}
}

void LCD12864_ULong(uchar   hang,uchar   lie,unsigned long dws)	// 1-4行；1-16列
{
	unsigned int cs=dws;

    uchar sz1[11]={0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,'\0'};
	uchar i=0;

	    for(;;i++)
	    {
	         if(cs/10==0)
		         break;
		     cs=cs/10;
	    }
		for(;i>=0;i--)
		{
			sz1[i]=dws%10+0x30;
			if(dws/10==0)
				break;
			dws=dws/10;
		}
        LCD12864_str_ram(hang,lie,sz1);
}
/*在12864第hang行第lie列开始显示Float 数据 */
void LCD12864_Float(uchar   hang,uchar   lie,float   ft) //// 1-4行；1-16列
{
	 uchar   sz[12];
	uchar i=0;
	long   dd,ff;
	if(ft>=0)
	{
	    if(ft<1.0)
	    {
		    sz[0]='0';
		    sz[1]='.';
		    dd=(long)(ft*1000);
		    sz[2]=dd/100+0x30;
		    sz[3]=dd%100/10+0x30;
		    sz[4]=dd%10+0x30;
		    sz[5]='\0';
	    }
	    else				//12.678
	    {
		    dd=(long)ft;
		    ff=dd;
    	    for(i=0;;i++)
	        {
		         if(dd/10==0)
			     break;
			     dd=dd/10;
		    }
		    sz[i+1]='.';
		    dd=(long)(ft*1000)%1000;
		    sz[i+2]=dd/100+0x30;
		    sz[i+3]=dd%100/10+0x30;
		    sz[i+4]=dd%10+0x30;
		    sz[i+5]='\0';
		    for(;;i--)
		    {
			    sz[i]=ff%10+0x30;
			    if(ff/10==0)
			    break;
	    		ff=ff/10;
		    }
	    }
	}  else	//LCD12864_str(hang,lie,sz);
	{
	    ft = -ft;
		if(ft<1.0)
	    {
		    sz[0]='-';
		    sz[1]='0';
		    sz[2]='.';
		    dd=(long)(ft*1000);
		    sz[3]=dd/100+0x30;
		    sz[4]=dd%100/10+0x30;
		    sz[5]=dd%10+0x30;
		    sz[6]='\0';
	    }
	    else				//12.678
	    {
		    sz[0]='-';
		    dd=(long)ft;
		    ff=dd;
    	    for(i=0;;i++)
	        {
		         if(dd/10==0)
			     break;
			     dd=dd/10;
		    }
			i++;
		    sz[i+1]='.';
		    dd=(long)(ft*1000)%1000;
		    sz[i+2]=dd/100+0x30;
		    sz[i+3]=dd%100/10+0x30;
		    sz[i+4]=dd%10+0x30;
		    sz[i+5]='\0';
		    for(;;i--)
		    {
			    sz[i]=ff%10+0x30;
			    if(ff/10==0)
			    break;
	    		ff=ff/10;
		    }
	    }
	}
		LCD12864_str_ram(hang,lie,sz);
}

/*在12864第hang行第lie列开始显示Float 数据 */
void LCD12864_Float4(uchar   hang,uchar   lie,double  ft) //// 1-4行；1-16列
{
	uchar   sz[14];	//12
	uchar i=0;
	long   dd,ff;

	if(ft<1.0)
	{
		sz[0]='0';
		sz[1]='.';
		dd=(long)(ft*10000);
		sz[2]=dd/1000+0x30;
		sz[3]=dd%1000/100+0x30;
		sz[4]=dd%100/10+0x30;
		sz[5]=dd%10+0x30;
		sz[6]='\0';
	}
	else				//12.6789
	{
		dd=(long)ft;
		ff=dd;
    	for(i=0;;i++)
	   {
		 if(dd/10==0)
			   break;
			dd=dd/10;
		}
		sz[i+1]='.';
		dd=(long)(ft*10000)%10000;
		sz[i+2]=dd/1000+0x30;
		sz[i+3]=dd%1000/100+0x30;
		sz[i+4]=dd%100/10+0x30;
		sz[i+5]=dd%10+0x30;
		sz[i+6]='\0';
		for(;;i--)
		{
			sz[i]=ff%10+0x30;
			if(ff/10==0)
			   break;
			ff=ff/10;
		}
	}
	//LCD12864_str(hang,lie,sz);
	LCD12864_str_ram(hang,lie,sz);
}

/*画图128*64的*/
void LCD_12864_P(  uchar  *a)  //显示图片函数 (a的长度一定要大于64*16)
{
    uchar   i,j,k,temp;
    write_12864_byte(0,0x34);//扩充指令
    write_12864_byte(0,0x36);//绘图显示开
//    Delay_nms(2);                //对于1T单片机来说这条延时很关键  普通单片机可以不加这条
    for(i=0;i<2;i++)
    {
        if(i==0)           //画上半屏
        temp=0;
        else
        temp=8;            //画下半屏
        for(j=0;j<32;j++)
        {
            write_12864_byte(0,(0x80+j));   //设置垂直地址(以位为单位,对应的行号)
            write_12864_byte(0,(0x80+temp));//设置水平地址(以字节单位,对应的列号)指针可自增
            for(k=0;k<16;k++)
            {
                write_12864_byte(1,*a++);
            }
        }
    }
    write_12864_byte(0,0x30);//基本指令
}
void LCD12864_Uint(uchar   hang,uchar   lie,uint   zs)
{
	uchar   sz[6]={0x20,0x20,0x20,0x20,0x20,'\0'};
	uchar i=0;
    uint   cs=zs;

	for(;;i++){
		if(cs/10==0) break;
		cs=cs/10;
	}
	for(;;i--){
		sz[i]=zs%10+'0';
		if(zs/10==0) break;
		zs=zs/10;
	}
	//LCD12864_str( hang,lie,sz);
	LCD12864_str_ram(hang,lie,sz);
}
/***************************************************/

/*--  调入了一幅图像：C:\Users\Administrator\Desktop\BIQ.bmp  --*/
/*--  宽度x高度=128x64  --*/
/*uchar  tab[]=
{
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x01,0xFD,0xF0,0x1F,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x01,0xFC,0xE1,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x03,0xFC,0x0A,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x07,0xFC,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x0F,0xEC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x1F,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x3F,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x7F,0x98,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x01,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x07,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x0D,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x37,0xBF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x7D,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xFE,0x3D,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x01,0xBF,0xE9,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x03,0xEF,0xB0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x07,0xFF,0xE1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0F,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1F,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x3F,0xBF,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x31,0xFB,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x7F,0xDE,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xFD,0xEF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x01,0xFF,0xFB,0xE0,0x00,0x80,0x04,0x20,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x01,0xFF,0xDF,0xE0,0x08,0x00,0x1D,0x90,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x03,0xFF,0xEF,0xF0,0x1B,0x00,0x3F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x0F,0xFF,0x7F,0xC0,0x3E,0x00,0x39,0x12,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x0F,0xEF,0xFF,0xE0,0x3C,0x00,0x3F,0x05,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x1F,0xFD,0xFF,0xE1,0xF8,0x04,0x3F,0xB8,0xC8,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x3F,0xBF,0xFF,0xD4,0xF0,0x1E,0x3A,0x54,0xD8,0x01,0xD0,0x00,0x00,0x00,
0x00,0x00,0x7F,0xFF,0xFF,0xFF,0xE0,0x60,0x1F,0x54,0xF9,0x03,0xB0,0x00,0x00,0x00,
0x00,0x00,0xFF,0xFF,0xE0,0x7F,0xC0,0x00,0x3F,0xF4,0xFD,0x03,0xF4,0x00,0x00,0x00,
0x00,0x00,0xFB,0xFF,0xE0,0x37,0x00,0x00,0x00,0xE4,0x7D,0x03,0xF4,0x00,0x00,0x00,
0x00,0x01,0xFF,0xFF,0xC0,0x7E,0x80,0x00,0x00,0x40,0x7D,0x43,0xEC,0x20,0x00,0x00,
0x00,0x01,0xFF,0xFF,0xC0,0x9C,0x00,0x00,0x00,0x40,0xFD,0xC3,0xFD,0x20,0x00,0x00,
0x00,0x03,0xFF,0xFF,0xC1,0xF8,0x00,0x00,0x00,0x40,0xFF,0xE3,0xFD,0x60,0x00,0x00,
0x00,0x03,0xFF,0xFF,0x03,0x60,0x00,0x00,0x00,0x00,0x7F,0xE3,0xFF,0x40,0x00,0x00,
0x00,0x07,0xFF,0xFF,0xB4,0x84,0xC0,0x00,0x00,0x01,0x3F,0xE3,0xFF,0xE0,0x00,0x00,
0x00,0x07,0xFF,0xFF,0x90,0x05,0xC0,0x00,0x00,0x08,0xBF,0xC1,0xF7,0xC0,0x00,0x00,
0x00,0x0F,0xFB,0xEF,0xE4,0x04,0x20,0x00,0x00,0x01,0x3F,0xC1,0xFF,0x40,0x00,0x00,
0x00,0x1F,0xFF,0xFF,0xE0,0x08,0x00,0x00,0x00,0x02,0x3F,0x81,0xF7,0x00,0x00,0x00,
0x00,0x1B,0xF3,0xFF,0xE0,0x00,0x00,0x00,0x00,0x02,0xFF,0x81,0xF7,0x80,0x00,0x00,
0x00,0x37,0x9F,0xFE,0xE4,0x00,0x00,0x00,0x00,0x02,0xFF,0x01,0xFF,0x80,0x00,0x00,
0x00,0x4F,0x1F,0xF8,0xF0,0x10,0x00,0x00,0x00,0x07,0xFE,0x01,0xFF,0x00,0x00,0x00,
0x00,0xDE,0x3F,0xF0,0x1F,0xF8,0x00,0x00,0x00,0x0F,0xFE,0x01,0xFD,0x00,0x00,0x00,
0x00,0xBC,0x3F,0xC0,0x03,0xF8,0x40,0x00,0x00,0x0F,0xFC,0x01,0xFC,0x00,0x00,0x00,
0x00,0x70,0x7F,0xC0,0x0F,0xF1,0x80,0x00,0x00,0x1F,0xFC,0x01,0xFC,0x00,0x00,0x00,
0x00,0xE0,0x6F,0x00,0x1F,0xC7,0x00,0x00,0x00,0x1F,0xFC,0x01,0xEE,0x00,0x00,0x00,
0x00,0xC0,0xEE,0x00,0x3F,0xF1,0x00,0x00,0x00,0x1F,0x78,0x01,0xAE,0x00,0x00,0x00,
0x01,0x80,0xFC,0x00,0x3F,0xFE,0x00,0x00,0x00,0x1D,0x78,0x01,0xFC,0x00,0x00,0x00}
;*/

